#include <bits/stdc++.h>
using namespace std;
using ll=long long;
/*あらかじめAとBを用意して順番どおりに表示させればOK?
1 2 3 4 5
9 7 5 3 1
10 9 8 7 6
ああ、意味分かった。出力順の和を満たす必要があるのか
5   4  3  2  1
1   2  3  4  5 A
100 98 96 94 92 B

1   2  3  4  5
1   3  5  7  9 A
100 99 98 97 96 B

5 2  1  4  3
1 2  3  7  8 A
1との差をたしていく感じ？
5  7  8  12 15 A 順位をそのまま足す
99 96 92 91 89 5との差をさげる
2乗する
25 29 30 46 55
99 90 74 73 69
124119104119124

25 29 30 46 55
99 96 92 91 89 5との差をさげる
124125122137144

Aに加算、Bに減産していく感じ？
20000*20000ってアウトかな
5 2 1 4 3
1 2 3 4 5
5 4 3 2 1

Aは固定でBで調整か
うまくいかん。順位が高いものは大きく、小さいものは小さく。
5 2  1  4  3
1 2  3  7  8 A
1との差をたしていく感じ？
5  7  8  12 15 A 順位をそのまま足す
99 94 92 91 87 総合値からひいて、あてはめてみる
104101100103102
1  5  2  3  4
1  6  8  11 15
100 99 94 92 89
101105102103104
なんかいいかも。
ルール間違ってた･･･。
2 3 1として
大きさが2<3<1
N+1の差をたしてくA
2  3  1
2  3  6
2 3 1、大きさ順位は
3 1 2
3  4  6 Aは順位の差をたす
96 93 92 Bは総合との差 
99 97 98

*/
int main(){
  ll N; cin>>N;
  vector<ll> A(N+1,0), B(N+1,0), C(N+1,1e9), P(N+1,0);
  //順位が高いほうが高得点
  for(int i=1; i<=N; i++){
    ll p; cin>>p;
    P[p]=i;
    C[p]+=i;//総合点。後にでてくるほど加点iが大きい
  }
  //Aつくる
  ll sum=0;
  for(int i=1; i<=N; i++){
    sum+=P[i];
    A[i]=sum;
  }
  for(int i=1; i<=N; i++) B[i]=C[i]-A[i];
  for(int i=1; i<=N; i++){
    cout<<A[i];
    if(i==N)
      cout<<endl;
    else
      cout<<" ";
  }
  for(int i=1; i<=N; i++){
    cout<<B[i];
    if(i==N)
      cout<<endl;
    else
      cout<<" ";
  }
}