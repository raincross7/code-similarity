#include <bits/stdc++.h>
using namespace std;
using ll=long long;
/*
Aをいれかえて全合格。そのとき、動いたものの最小数
sortすれば-1判定はできる
sortして、左から右へは交換可能か。
同じ数字OKがきつい
まずBでsortしてナンバリングするか？
Bが同じ数字だったときのナンバリングのずれか

A235
B341

 012numb
A523
B134sort

 120
A235sort
B134

A233
B221

 012numb
 332
B122sort

 201
A233sort
B122

6
1 2 3 5 6 4
2 2 2 1 5 5
3ってでるはずなのに4だな

A123564
B222155

A512364
B122255

 012345が正しい
 123504
A123456
B122255

 012345が正しい
 132504
A132456
B122255

 012345が正しい
 152304
A142356
B122255

 012345が正しい
 152340←これがかえられるのか
A142365
B122255

63189252 64991604   11 0
74164189 195848680  8  1
78303147 740174259  2  2
98239366 372327760  3  3
110823640 440075441 9  4
118867039 458054863 5  5
122948912 529866931 6  6
147060907 354974235 7  7
362739947 463477172 0  8
465611891 632963102 4  9
501410831 615762794 10 10
572905212 757232153 1  11

63189252  64991604  11 0確定
74164189  757232153 1  1
78303147  740174259 2  2
98239366  372327760 3  3
110823640 440075441 9  4
118867039 458054863 5  5
122948912 195848680 8  6
147060907 354974235 7  7
362739947 463477172 0  8
465611891 529866931 6  9
501410831 615762794 10 10
572905212 632963102 4  11　1,2,4

sortしたあと、なるべく小さいのが末尾にくるようにしてみる？
該当するものが無い場合、一番低い数をいれる？
その低い数が適当だったらOUT
もともとみたしているものが候補。
みたしてないのとみたしてるのソート。

問題勘違いしてた。総和が等しい、か。
数字は自由に選べて、そのうえでいくつかえらえれるか、か。
AとBの差をだす。
A-B>=0なら変更しなくてもすむ可能性ある。
A-B<0なら、だめ
総和を出して、A-Bが割り振りできるポイント。
差が小さいものから採択していけばいいか。
*/
int main(){
  ll N,ans=0; cin>>N;
  vector<ll> A(N,0),B(N,0),D(N,0);
  for(ll i=0; i<N; i++) cin>>A[i];
  for(ll i=0; i<N; i++) cin>>B[i];
  ll asum=0,bsum=0;
  for(ll i=0; i<N; i++) asum+=A[i];
  for(ll i=0; i<N; i++) bsum+=B[i];
  ll p=asum-bsum;//自由に割り振れるポイント。
  if(p<0){
    cout<<-1<<endl;
    return 0;
  }
  for(ll i=0; i<N; i++) D[i]=A[i]-B[i];
  sort(D.begin(), D.end());
  for(ll i=0; i<N; i++){
    if(p-D[i]<0) break;
    if(D[i]>=0){
      p-=D[i];
      ans++;
    }
  }
  cout<<N-ans<<endl;
}