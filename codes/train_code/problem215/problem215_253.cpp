#include <bits/stdc++.h>
using namespace std;
using ll=long long;
/*
桁DPでいけそう
101桁まで
そうでもないかな･･･。
最後の端数が難しい
2500
2
2400
0025
0011

9999から
2501までをひく
それできるなら2500までだせるか
うーん
1999まで確定
2500まで最後まで個別判断とかややこしい
2がきたら候補
1以下はOK

5がきたら候補
1-9以下きたらOK
1999と2000-2500にわけるとかか

25だとして
　 [2 5]
  0 1 2
0 1 1 1             1
1 0 1 10//10 01-09  11//20
2 0 0 9//11-19      13//21-24

うーん･･･
n-1いれて9倍まではよくて
i-1]+1
i]+nとかかな

256
　 [2 5  6]
  0 1 2  3
0 1 1 1  1
1 0 2 11 20
2 0 0 14 113
3 0 0 0  123//14*9-3(987)

時間かかるけどDP例書かないとわからないぽんこつ

100
　 [1 0  0]
  0 1 2  3
0 1 1 1  1
1 0 1 10 19
2 0 0 0  81(101~109)
3 0 0 0  0//
これだめだ

120
　 [1 2  0]
  0 1 2  3
0 1 1 1  1
1 0 1 10 19
2 0 0 2  92
3 0 0 0  9//

1000
　 [1  0  0   0]
  0 1  2  3   4
0 1 1  1  1   1  
1 0 1 10 19  28
2 0 0  0 81 243 (-9はここ）
3 0 0  0  0 729
4 0 0  0  0   0
これだめだ

最後の桁前で、
1010
1011-1019を除く＝j=3
1010101=1010102~1010109=DP[i][4]-=8
*/
int main(){
  string S; cin>>S;
  ll K,ssz=S.size(), cnt=1;
  cin>>K;
  vector<vector<ll>> DP(110,vector<ll>(110,0));
  for(ll i=0; i<=ssz; i++) DP[i][0]=1;
  for(ll i=1; i<=ssz; i++){
    ll n=S[i-1]-'0';
    for(ll j=1; j<=i; j++){
      DP[i][j]=DP[i-1][j];//0がくる
      DP[i][j]+=DP[i-1][j-1]*9;//確定したやつに1-9
    }
    DP[i][cnt]-=9-n;
    if(n>0) cnt++;
  }
  cout<<DP[ssz][K]<<endl;
}