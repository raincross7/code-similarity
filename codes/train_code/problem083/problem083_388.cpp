#include <bits/stdc++.h>
using namespace std;
typedef long long ll;


/*
隣接行列を参照渡しするといい感じに計算します。Nodeは0始まり
*/
template<typename Cost>
void warshall_floyd(vector<vector<Cost>> &d){
    int V = d.size();
    const Cost INF = numeric_limits<Cost>::max();

    for (int k=0;k<V;k++){
        for (int i=0;i<V;i++){
            for (int j=0;j<V;j++){
                if (d[i][k] != INF && d[k][j] != INF && d[i][k]+d[k][j]<d[i][j]){
                    d[i][j] = d[i][k]+d[k][j];
                }
            }
        }
    }
}

void solve(long long N, long long M, long long R, std::vector<long long> r, std::vector<long long> A, std::vector<long long> B, std::vector<long long> C){
        const ll INF = numeric_limits<ll>::max();
        vector<vector<ll>> graph(N,vector<ll>(N,INF));
        for (int i=0;i<M;i++){
            graph[A[i]-1][B[i]-1] = C[i];
            graph[B[i]-1][A[i]-1] = C[i];
        }
        for (int k=0;k<N;k++){
            graph[k][k]=0;
        }
        warshall_floyd<ll>(graph);
        ll minimum=INF;
        sort(r.begin(),r.end());
        do {
            ll sum = 0;
            for (int i=0;i<R-1;i++){
                if (graph[r[i]-1][r[i+1]-1]<INF) sum+= graph[r[i]-1][r[i+1]-1];
                else{
                    sum=INF;
                    break;
                }
            }
            minimum = min(sum,minimum);
        } while (std::next_permutation(r.begin(), r.end()));
        printf("%lld\n",minimum);

}   



// Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
int main(){
    long long N;
    scanf("%lld",&N);
    long long M;
    scanf("%lld",&M);
    long long R;
    scanf("%lld",&R);
    std::vector<long long> r(R);
    for(int i = 0 ; i < R ; i++){
        scanf("%lld",&r[i]);
    }
    std::vector<long long> A(M);
    std::vector<long long> B(M);
    std::vector<long long> C(M);
    for(int i = 0 ; i < M ; i++){
        scanf("%lld",&A[i]);
        scanf("%lld",&B[i]);
        scanf("%lld",&C[i]);
    }
    solve(N, M, R, std::move(r), std::move(A), std::move(B), std::move(C));
    return 0;
}
