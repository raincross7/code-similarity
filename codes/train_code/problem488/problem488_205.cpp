#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const long long MOD = 1000000007;

template <long long MOD_ = (long long)1e9 + 7>
class ModMath {
public:
    ModMath(int N = 0)
        : N_(N)
    {
    }

    template <class... Ts>
    constexpr long long mul(long long head, Ts&&... tail)
    {
        auto res = head;
        using swallow = std::initializer_list<int>;
        (void)swallow { (void(res = (res * tail) % MOD_), 0)... };
        return res;
    }

    template <class... Ts>
    constexpr long long add(long long head, Ts&&... tail)
    {
        auto res = head;
        using swallow = std::initializer_list<int>;
        (void)swallow { (void(res = (res + tail) % MOD_), 0)... };
        return res;
    }

    constexpr long long del(long long x, long long y)
    {
        auto res = x - y;
        if (res < 0) {
            res += MOD_;
        }
        return res;
    }

    constexpr long long pow(long long x, long long y)
    {
        long long ans = 1;
        while (y > 0) {
            if (y & 0x1) {
                ans = mul(ans, x);
            }
            x = mul(x, x);
            y >>= 1;
        }
        return ans;
    }

    constexpr void swap(long long& a, long long& b)
    {
        long long tmp = a;
        a = b;
        b = tmp;
    }

    constexpr long long inv(long long a)
    {
        long long b = MOD_, u = 1, v = 0;
        while (b) {
            long long t = a / b;
            a -= t * b;
            swap(a, b);
            u -= t * v;
            swap(u, v);
        }
        u %= MOD_;
        if (u < 0) {
            u += MOD_;
        }
        return u;
    }

    constexpr long long comb(long long n, long long k)
    {
        if (k < 0 || k > n) {
            return 0;
        }
        auto min_k = std::min(k, n - k);
        long long x = 1;
        for (long long i = 0; i < min_k; i++) {
            x = mul(x, n - i);
        }
        long long y = 1;
        for (long long i = 0; i < min_k; i++) {
            y = mul(y, i + 1);
        }

        return mul(x, inv(y));
    }

    long long combination(long long n, long long k)
    {
        if (k < 0 || k > n) {
            return 0;
        }
        if (fact_.empty()) {
            build_fact();
        }
        return mul(fact_[n], fact_inv_[k], fact_inv_[n - k]);
    }

private:
    void build_fact()
    {
        if (!fact_.empty()) {
            return;
        }
        fact_.resize(N_ + 1);
        fact_[0] = 1;
        for (long long i = 1; i <= N_; i++) {
            fact_[i] = mul(fact_[i - 1], i);
        }
        fact_inv_.resize(N_ + 1);
        fact_inv_[N_] = pow(fact_[N_], MOD_ - 2);
        for (long long i = N_ - 1; i >= 0; i--) {
            fact_inv_[i] = mul(fact_inv_[i + 1], (i + 1));
        }
    }

    int N_;
    std::vector<long long> fact_;
    std::vector<long long> fact_inv_;
};

void solve(long long N, long long K)
{
    ModMath<MOD> m(N + 1);

    ll ans = 0;
    for (ll i = K; i <= N + 1; i++) {
        ans += (N + N - i + 1) * i / 2 - (i - 1) * i / 2 + 1;
        ans %= MOD;
    }
    cout << ans << endl;
}

// Generated by 1.1.7.1 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
// clang-format off
#pragma GCC diagnostic ignored "-Wunused-result"
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    long long N;
    scanf("%lld",&N);
    long long K;
    scanf("%lld",&K);
    solve(N, K);
    return 0;
}
