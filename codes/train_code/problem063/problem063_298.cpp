/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */

#include <iostream>
#include <fstream>

#include <iostream>
#include "bits/stdc++.h"

using namespace std;

typedef unsigned long long ll;
typedef int                     integer;
#define int                     long long
#define ii                      pair<int,int>
#define vii                     vector<pair<int,int>>
#define vi                      vector<int>
#define vvi                     vector<vector<int>>
#define f(a,b,c)                for(int a=(b);a<(c);a++)
#define s(x)                    in>>x
#define s2(x,y)                 in>>x>>y
#define s3(x,y,z)               in>>x>>y>>z
#define s4(x,y,z,w)             in>>x>>y>>z>>w
#define p(x)                    out<<(x)<<endl
#define p2(x,y)                 out<<(x)<<" "<<(y)<<endl
#define pl(x)                   out<<(x)
#define p2l(x,y)                out<<(x)<<" "<<(y)
#define p1d(a,n)                for(int ix=0;ix<(n);ix++) out<<a[ix]<<" "; out<<endl
#define p2d(a,n,m)              for(int ix=0;ix<(n);ix++){ for(int jx=0;jx<(m);jx++) out<<a[ix][jx]<<" "; out<<endl;}
#define range(v)                v.begin(),v.end()
#define w(x)                    while(x--)
#define rst(x)                  memset(x, -1, sizeof(x))

#define MAXN   2000001

int spf[MAXN];

// Calculating SPF (Smallest Prime Factor) for every
// number till MAXN.
// Time Complexity : O(nloglogn)
void sieve()
{
    spf[1] = 1;
    for (int i=2; i<MAXN; i++)

        // marking smallest prime factor for every
        // number to be itself.
        spf[i] = i;

    // separately marking spf for every even
    // number as 2
    for (int i=4; i<MAXN; i+=2)
        spf[i] = 2;

    for (int i=3; i*i<MAXN; i++)
    {
        // checking if i is prime
        if (spf[i] == i)
        {
            // marking SPF for all numbers divisible by i
            for (int j=i*i; j<MAXN; j+=i)

                // marking spf[j] if it is not
                // previously marked
                if (spf[j]==j)
                    spf[j] = i;
        }
    }
}

// A O(log n) function returning primefactorization
// by dividing by smallest prime factor at every step
set<int> getFactorization(int x)
{
    set<int> ret;
    while (x != 1)
    {
        ret.insert(spf[x]);
        x = x / spf[x];
    }
    return ret;
}

void ssolve(std::istream& in, std::ostream& out){
    int n;
    s(n);

    vi a(n);

    f(i, 0, n) s(a[i]);

    int gc = __gcd(a[0], a[1]);
    f(i,0,n) gc = __gcd(gc, a[i]);
    if(gc >1) {
        out << "not coprime" << endl;
        return;

    }
    sieve();

    map<int,int> dist;
    f(i,0,n) {
        auto primes = getFactorization(a[i]);
        for(auto x: primes) {
            dist[x]++;
        }
    }
    bool pairwise = true;

    for(auto k:dist) {
        if(k.second>1) {
            pairwise = false;

        }
    }
    out<<(pairwise? "pairwise coprime": "setwise coprime")<<endl;




}

class ECoprime {
public:
	void solve(std::istream& in, std::ostream& out) {
        ios_base::sync_with_stdio(false);
        in.tie(0);out.tie(0);
        int t;
        int READ = 0;
        if(READ) s(t);
        else t = 1;
        while(t--){
            ssolve(in, out);
        }
	}
};


integer main() {
	ECoprime solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
}
